平行化射飛鏢求pi過程
===

[作業要求](https://people.cs.nctu.edu.tw/~ypyou/courses/PP-f19/assignments/HW1.pdf)

執行結果：  

| core\執行次數|    10M    |   100M   |   1000M   |  
|  --------   | --------  | -------- | -------- | 
| 1           | 0.138s    | 1.263s   |   12.550s  | 
| 2           | 0.076s    | 0.679s   |   6.686s   | 
| 4           | 0.045s    | 0.363s   |   3.534s   | 


#### 遇到的主要問題

為什麼用越多thread，所花的時間反而越久？  
在求助於BK大神後，這是餵狗找出的答案，原來以前也有學長遇過類似的問題。  
[大神解答]](https://medium.com/@kweisamx0322/rand-%E8%88%87-rand-r%E7%9A%84%E5%B7%AE%E7%95%B0-70c4bfc201f6)  
算是又學到了一課，以下是歸納筆記：  
我原本使用的是`srand()`這個取亂數函式，他跟最基本的`rand()`差別在於`rand()`是從0~MAX中隨機選一個整數，再由第n-1次取的亂數去生成第n次取的亂數，而`rand()`都是從0開始的，所以重複跑這個程式會發現出現的順序是固定的。`srand()`則會去改變初始的0，但也不完全是隨機取，他需要一個seed去決定要改成什麼，相同的seed就可以得到相同的結果，因此常會將seed設成Time，也就是現在的時間，因為時間會不斷地改變，所以每次執行程式就可以得到一個無法預期的隨機值。  

使用`srand()`雖然解決上述問題，但會遇到越多thread反而跑越慢的現象，根據大神的解答，`srand()`應該是保有`rand()`的另一個特性--`lock`，本意是不希望在跑平行化程式時，跑在不同core上的thread同時呼叫rand的共用data，因為這樣可能會得到一樣的隨機值，因此把它lock住讓共用data一次只能由一個thread讀，因此不同的thread在需要取亂數時都要等另一個thread讀完，會多出很多等待的時間，尤其是thread越多排隊的人就越長，花的時間就越久。  

`rand_r`可以解決上述問題，跟前面不同的是，`srand()`只需要在函式內設定一次seed就好，而`rand_r`每次呼叫時都要傳入一個seed，由於每次呼叫都用一個新的seed，不會和其他thread共用，也就沒有lock的問題了。  